From a7d919307435b6344234568405e20f6234578857 Mon Sep 17 00:00:00 2001
From: Jan Janssen <janssen@mpie.de>
Date: Tue, 14 May 2024 08:15:23 -0500
Subject: [PATCH] add header files

---
 matid/ext/celllist.h | 106 +++++++++++++++++++++++++++++++++++++++++++
 matid/ext/geometry.h |  89 ++++++++++++++++++++++++++++++++++++
 2 files changed, 195 insertions(+)
 create mode 100644 matid/ext/celllist.h
 create mode 100644 matid/ext/geometry.h

diff --git a/matid/ext/celllist.h b/matid/ext/celllist.h
new file mode 100644
index 0000000..c97f69d
--- /dev/null
+++ b/matid/ext/celllist.h
@@ -0,0 +1,106 @@
+/*Copyright 2019 DScribe developers
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+#ifndef CELLLIST_H
+#define CELLLIST_H
+
+#include <pybind11/numpy.h>
+#include <vector>
+
+namespace py = pybind11;
+using namespace std;
+
+struct CellListResult {
+    vector<int> indices;
+    vector<double> distances;
+    vector<double> distances_squared;
+    vector<vector<double>> displacements;
+    vector<int> indices_original;
+    vector<vector<double>> factors;
+};
+
+/**
+ * For calculating pairwise distances using a cell list.
+ */
+class CellList {
+    public:
+        /**
+         * Constructor
+         *
+         * @param positions Atomic positions in cartesian coordinates.
+         * @param atomicNumbers Atomic numbers.
+         */
+        CellList(py::array_t<double> positions, py::array_t<int> indices, py::array_t<double> factors, double cutoff);
+        /**
+         * Get the indices of atoms within the radial cutoff distance from the
+         * given position.
+         *
+         * @param x Cartesian x-coordinate.
+         * @param y Cartesian y-coordinate.
+         * @param z Cartesian z-coordinate.
+         */
+        CellListResult get_neighbours_for_position(const double x, const double y, const double z);
+        /**
+         * Get the indices of atoms within the radial cutoff distance from the
+         * given atomic index. The given index is not included in the returned
+         * values.
+         *
+         * @param i Index of the atom for which neighbours are queried for.
+         */
+        CellListResult get_neighbours_for_index(const int i);
+        /**
+         * Used to calculate the full displacement tensor in an efficient
+         * manner.
+         */
+        void get_displacement_tensor(
+            py::array_t<double> displacements,
+            py::array_t<double> distances,
+            py::array_t<double> factors,
+            py::array_t<int> original_indices,
+            int n_atoms
+        );
+        py::array_t<int> indices_py;
+
+    private:
+        /**
+         * Used to initialize the cell list. Querying for distances is only
+         * possible after this initialization.
+         */
+        void init();
+
+        // const py::detail::unchecked_reference<double, 2> positions;
+        // const py::detail::unchecked_reference<int, 1> indices;
+        // const py::detail::unchecked_reference<double, 2> factors;
+        vector<vector<double>> positions;
+        vector<int> indices;
+        vector<vector<double>> factors;
+        const double cutoff;
+        const double cutoffSquared;
+        double xmin;
+        double xmax;
+        double ymin;
+        double ymax;
+        double zmin;
+        double zmax;
+        double dx;
+        double dy;
+        double dz;
+        int nx;
+        int ny;
+        int nz;
+        vector<vector<vector<vector<int>>>> bins;
+};
+
+#endif
diff --git a/matid/ext/geometry.h b/matid/ext/geometry.h
new file mode 100644
index 0000000..16e7afd
--- /dev/null
+++ b/matid/ext/geometry.h
@@ -0,0 +1,89 @@
+/*Copyright 2019 DScribe developers
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+#ifndef GEOMETRY_H
+#define GEOMETRY_H
+
+#include <vector>
+#include <stdexcept>
+#include <pybind11/numpy.h>
+#include "celllist.h"
+
+namespace py = pybind11;
+using namespace std;
+
+struct ExtendedSystem {
+    py::array_t<double> positions;
+    py::array_t<int> atomic_numbers;
+    py::array_t<int> indices;
+    py::array_t<double> factors;
+};
+
+inline vector<double> cross(const vector<double>& a, const vector<double>& b);
+inline double dot(const vector<double>& a, const vector<double>& b);
+inline double norm(const vector<double>& a);
+
+/**
+ * Used to periodically extend an atomic system in order to take into account
+ * periodic copies beyond the given unit cell.
+ *
+ * @param positions Cartesian positions of the original system.
+ * @param atomic_numbers Atomic numbers of the original system.
+ * @param cell Unit cell of the original system.
+ * @param pbc Periodic boundary conditions (array of three booleans) of the original system.
+ * @param cutoff Radial cutoff value for determining extension size.
+ *
+ * @return Instance of ExtendedSystem.
+ */
+ExtendedSystem extend_system(
+    py::array_t<double> positions,
+    py::array_t<int> atomic_numbers,
+    py::array_t<double> cell,
+    py::array_t<bool> pbc,
+    double cutoff
+);
+
+/**
+ * Returns a CellList instance for the given atomic system.
+ *
+ * Note that you should control how large extension should be performed to take
+ * into account the periodic boundary conditions, as the CellList internally
+ * works with plain cartesian coordinates.
+ */
+CellList get_cell_list(
+    py::array_t<double> positions,
+    py::array_t<double> cell,
+    py::array_t<bool> pbc,
+    double extension,
+    double cutoff
+);
+
+/**
+ * Calculates a pairwise displacement tensor (distance vectors) with a given
+ * cutoff.
+ */
+void get_displacement_tensor(
+    py::array_t<double> displacements,
+    py::array_t<double> distances,
+    py::array_t<double> factors,
+    py::array_t<double> positions,
+    py::array_t<double> cell,
+    py::array_t<bool> pbc,
+    double cutoff,
+    bool return_factors,
+    bool return_distances
+);
+
+#endif
